<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
	<title>5.1. Права доступа</title>
</head>
<link rel="stylesheet" href="../../styles.css">
<body style="margin: 0px 150px 0px 150px">

<table summary="Header navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<th colspan="3" align="center">Администрирование Calmira GNU/Linux</th>
</tr>

<table summary="Footer navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<td width="33%" align="left" valign="top"><a href="index.html"
accesskey="P">Назад</a></td>
<td width="34%" align="center" valign="top"><a href="index.html"
accesskey="H">Домой</a></td>
<td width="34%" align="right" valign="top"><a href="processes.html"
accesskey="N">Далее</a></td>

</tr>

<tr>
<td width="33%" align="left" valign="top">Администрирование системы</td>
<td width="34%" align="center" valign="top">&nbsp;</td>
<td width="33%" align="right" valign="top">Управление процессами</td>
</tr>
</table>

<hr align="LEFT" width="100%" />

<script src="table.js">
</script>

<h1>5.1. Права доступа</h1>

<p>В данной инструкции приведены базовые сведенья об управлении правами доступа и привилегиях суперпользователя. Под <em>управлением доступом</em> подразумевается механизм принятия решений, связанных с безопасностью, в первую очередь.</p>

<h2>Работа с правами доступа на файлы</h2>

<h3>Введение</h3>

<p>В отличии от DOS и ей подобных систем, UNIX проектировалась как многопользовательская система. Поэтому в ней должны быть хотя бы примитивные подсистемы для управлением правами доступа к файлам, чтобы, например, <em>обычный</em> пользователь <tt>&lt;user1&gt;</tt> не удалил случайно (либо по злому умыслу) файлы из <tt>/bin</tt>, либо любые другие системные файлы или файлы других пользователей. На самом деле, примеров можно привезти много.</p>

<p>Стандартная модель управления доступом в UNIX в течение десятилетий практически не изменилась. С некоторыми изменениями она доступна нам и сегодня и применяется как в Linux, так и в других UNIX-подобных/образных системах. Ниже представлена модель доступа.</p>

<ul>
	<li>Решение по управлению доступом зависят от того, какой пользователь пытается выполнить операцию.</li>
	<li>Объекты (например, файлы, процессы и пр.) имеют владельцев, которые имеют широкий (но не обязательно неограниченный) контроль над своими объектами.</li>
	<li>Вы являетесь владельцем создаваемых вами объектов.</li>
	<li>Только пользователь <tt>root</tt> может действовать как владелец любого объекта и выполнять важные административные операции с системой.</li>
</ul>

<h3>Пользователь <tt>root</tt></h3>

<p>Пользователь <tt>root</tt> имеет больше всего привелегий в системе. Его так же называют "<em>суперпользователем</em>". Идентивикатор <tt>UID</tt> равен нулю.</p>

<p>Суперпользователю (т.е. любому процессу, для которого текущий идентификатор <tt>UID</tt> = 0) позволяется выполнять любую допустимую операцию для любого файла или процесса (но некоторые операции, такие как исполнение файла как программы, для которого не установлен бит разрешения на запуск, запрещены даже для <tt>root</tt>). Как только процесс <tt>root</tt> изменит своего владельца и станет обычным пользовательским процессом, он не сможет воссатновить прежнее привилегированное состояние.</p>

<h3>Вход в учётную запись пользователя <tt>root</tt></h3>

<p>Несмотря на то, что во многих дистрибутивах Linux эта учётная запись по умолчанию отключена, в Calmira GNU/Linux этого не планируется. Однако мы вам <b>не советуем</b> пользоваться этой учётной записью для решения определённых задач, которые решаются куда более безопасными методами.</p>

<p>Лучше всего получать доступ к учётной записи (УЗ) <tt>root</tt> с помощью команды <tt>su</tt>. При вызове без аргументов она запросит у вас пароль от УЗ <tt>root</tt>. Пароль по умолчанию: <em>root</em> (т.е. такой же, как и название УЗ). <b>ОБЯЗАТЕЛЬНО</b> поменяйте его (об этом в следующем пункте). Так же, с помощью <tt>su</tt> можно получать доступ к УЗ и других пользователей. Для этого выполните:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
su <em>$USER</em>
</pre></td></tr></table>

<p>Заменив <tt><em>$USER</em></tt> на имя нужного пользователя.</p>

<h3>Использование утилиты <tt>sudo</tt></h3>

<p>Программа sudo принимает в качестве аргумента командную строку, выполняемую с правами <tt>root</tt> (или правами любого другого ограниченного пользователя). Она проверяет файл <tt>/etc/sudoers</tt>, в ко­тором перечислены пользователи, имеющие разрешение использовать <tt>sudo</tt> и команды, которые им можно запускать на каждом хосте. Если предлагаемая команда разрешена, <tt>sudo</tt> запрашивает собственный пароль пользователя и выполняет команду.</p>

<p>По умолчанию, <tt>sudo</tt> позволяет выполнять команды без введения пароля пользователя в течение пяти минут, хотя время тайм аута можно менять (но не советуется).</p>

<h3>Пример записи в <tt>sudoers</tt></h3>

<p>В данном пункте представлены сведенья по настройке sudo</p>

<p>По умолчанию, эта программа не установлена. Установите её из порта <tt>optional/sudo</tt>. После сборки и установки Система портов спросит у вас, настраивать ли этот порт или нет. Выберите "Да". Будет создана базовая конфигурация. Но вам может понадобиться перенастроить порт под свои нужды.</p>

<p>Настройки хранятся в <tt>/etc/sudoers</tt>. Редактировать файл <tt>sudoers</tt> "вручную" — плохая практика. Для редактирования есть специальная команда <tt>visudo</tt>. Она сама знает, где расположен файл <tt>sudoers</tt>, и отследит, чтобы вы редактировали копию этого файла во избежание ошибок, а основной файл всегда был целостным.</p>

<p>Программа <tt>visudo</tt> использует тот редактор, который прописан в переменной окружения <em><tt>EDITOR</tt></em>. В Calmira GNU/Linux по умолчанию это <tt>/usr/bin/vim</tt>, но вы можете установить свой, выполнив:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
export EDITOR=<em>ваш_редактор</em>
</pre></td></tr></table>

<p>После чего выполните от имени <tt>root</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
visudo
</pre></td></tr></table>

<p>Если вы допустите ошибку, то, при выходе из редактора получите сообщение вида:</p>

<table border="1" width="100%" cellpadding="5">
<tr><td>
<pre>
visudo: >>> /etc/sudoers: syntax error near line 73 <<<
What now?
</pre></td></tr></table>

<p>Полномочия для каждого пользователя описываются в следующем виде:</p>

<ul>
	<li>Пользователь, к которому относится запись;</li>
	<li>Хосты, на которые распространяется запись;</li>
	<li>Разрешённые команды;</li>
</ul>

<p>Формат текстовой записи будет такой:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
[пользователь] [хост]=([кем может стать]) [что может сделать]
</pre></td></tr></table>

<p>Например:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
user1 ALL=(root) /bin/mount
</pre></td></tr></table>

<p>Эта строка означает, что пользователь <tt>user1</tt> может выполнять с правами <tt>root</tt> команду <tt>/bin/mount</tt>. <b>Обязательно</b> указывайте <em>полный путь</em> до команды!</p>

<p><strong><img src="../../pic/note.png" /> ВНИМАНИЕ!</strong></p>
<p><blockquote>К сожалению, очень большое число пользователей отключают запрос пароля (<tt>NOPASS</tt>). Они это делают ради лени, так как не хотят вводить длинные и сложные пароли. Мы настоятельно <b>НЕ РЕКОМЕНДУЕМ</b> использовать такой подход, так как он очень небозопасный. Если у ПК окажется злоумышленник, то он может привести ваши данные или всю ОС в неработоспособное состояние.</blockquote></p>

<h2>Владельцы объектов</h2>

<p>Чтобы получить доступ к определённому объекту (далее будет употребляться термин "<em>файл</em>" и всё про них, другие объекты затронуты не будут) в Linux, используются разрешения, которые назначаются трём объектам: <em>файлу</em>, <em>группе</em> и другому объекту (т.е. всем остальным). Но перед этим нужно знать про владельца файла (директории не упоминаю специально, так как это тоже файл - концепция "Всё есть файл" в UNIX-подобных/образных).</p>

<p>В Linux у каждого файла есть два владельца: <em>пользователь</em> и <em>группа</em>. Они устанавливаются при создании файла. Каждый файл имеет три категории пользователей, для которых можно устанавливать различные сочетания прав доступа:</p>

<ol>
	<li><b>Владелец</b> - набор прав для владельца файла - пользователя, который создал его или сейчас установлен его владельцем. Обычно владелец имеет все права: <tt>чтение</tt>, <tt>запись</tt> и <tt>исполнение</tt>;</li>
	<li><b>Группа</b> - любая группа пользователей, существующая в ОС и привязанная к файлу;</li>
	<li><b>Остальные</b> - все пользователи (кроме владельца и юзеров, входящих в группу файла);</li>
</ol>

<p><blockquote>Только пользователь <em>root</em> (он же суперпользователь) может работать со всеми файлами независимо от набора их полномочий.</blockquote></p>

<p>Пользователь, создавший файл, становится его владельцем, так же как и первичная группа, в которую входит этот юзер. Чтобы определить, есть ли у вас, как у пользователя, права доступа к файлу, оболочка проверяет владение им. Принцип работы таков:</p>

<ol>
	<li>Оболочка проверяет, являетесь ли вы владельцем файла, к которому запрашивается доступ. Если владельцем являетесь, то оболочка прекращает проверку и вы получаете разрешения. Если вы не являетесь владельцем, но входите в группу, у которой есть доступ к файлу, то вы получаете доступ к файлу с теми же разрешениями, что и у той группы.</li>
	<li>Если же вы не являетесь ни пользователем, ни владельцем группы, то вы получаете права других пользователей (`other`).</li>
</ol>

<p><blockquote>Каждый пользователь может получить полный доступ к файлу в том случае, если доступ ему разрешён. Либо же, если он является владельцем файла.</blockquote></p>

<p>Чтобы увидеть пользователя и группу-владельца файла, выполните:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
ls -l
</pre></td></tr></table>

<p>Чтобы просмотреть тоже самое, но для конкретного файла:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
ls -l <em>$FILE</em>
</pre></td></tr></table>

<p>Замените <em><tt>$FILE</tt></em> на имя нужного файла.</p>

<h2>Изменение владельца файла</h2>

<p>Очень часто системным администраторам (и обычным пользователям, но реже) требуется по каким-то причинам изменить владельца файла. Для смены владельца используется программа <tt>chown</tt> (<tt>change owner</tt>).</p>

<h4>Синтаксис <tt>chown</tt></h4>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chown пользователь опции /путь/к/файлу
</pre></td></tr></table>

<h4>Ключи и опции <tt>chown</tt></h4>

<ul>
	<li><tt>-c --changes</tt> - подробный вывод всех выполняемых операций;</li>
	<li><tt>-v --verbose</tt> - описание действий и вывод подробных данных о каждом обработанном файле;</li>
	<li><tt>-R --recursive</tt> - рекурсивная обработка всех подкаталогов;</li>
	<li><tt>-f --silent --quiet</tt> - минимум информации, выводимой на экран, даже сообщения об ошибках;</li>
	<li><tt>--dereference</tt> - изменять права для файла, к которому ведёт символическая ссылка вместо самой ссылки (<em>по умолчанию</em>)</li>
	<li><tt>--no-dereference -h</tt> - изменять права симлинков, но оставить неизменными файлы, на которые указывают эти симлинки;</li>
	<li><tt>-L</tt> - переходить по всем симлинкам на каталоги;</li>
	<li><tt>-H</tt> - если передан симлинк на каталог, перейти по нему;</li>
	<li><tt>-P</tt> - не переходить по символическим ссылкам на каталоги (<em>по умолчанию</em>);</li>
</ul>

<h3>Примеры использования <tt>chown</tt></h3>

<p>Допустим, есть два пользователя: <tt>root</tt> и <tt>liveuser</tt>. В директории <tt>/root</tt> создана поддиректория <tt>/root/liveuser</tt>. Там ещё несколько файлов. Эта поддиректория принадлежит пользователю <tt>root</tt>, как и все файлы в ней. А надо сделать так, чтобы принадлежала пользователю <tt>liveuser</tt>. Выполнить в терминале:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chown liveuser /root/liveuser
</pre></td></tr></table>

<p>Если вы хотите видеть подробную информацию о проделанном действии, выполните:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chown -v liveuser /root/liveuser
</pre></td></tr></table>

<p>Но вы сменили владельца только для каталога <tt>/root/liveuser</tt>. А все подпапки и другие файлы, которые находятся в нём, так же принадлежат пользователю root. В тех подкаталогах ещё какие-то каталоги находятся. Можно, конечно, для каждого файла/каталога изменить владельца персонально, но это муторно, а если файлов много, то никто не будет с этим заморачиваться. Но проще же выполнить chown с ключом <tt>-R</tt>, дабы эта утилита рекурсивно обошла все подкаталоги и файлы, сменив их владельца:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chown -R liveuser /root/liveuser/
</pre></td></tr></table>

<p>Опять возвращаем всё в то состояние, которое было до экспериментов с <tt>chown</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chovn -Rv root /root/liveuser
</pre></td></tr></table>

<p>Если вы хотите поменять не только владельца, но и группу файла, то запишите имя пользователя и имя группы через двоеточие:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chown -v liveuser:liveuser /root/liveuser
</pre></td></tr></table>

<p>Теперь измените группу и владельца на <tt>liveuser</tt> только для тех файлов, у которых владелец и группа <tt>root</tt> в каталоге <tt>/root/liveuser/</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chown --from=root:root liveuser:liveuser ./
</pre></td></tr></table>

<h3>Изменение группы файла с помощью chgrp</h3>

<p>Для изменения группы файла используется команда <tt>chgrp</tt> (<em>change group</em>). В отличии от предыдущей описанной команды <tt>chown</tt>, для <tt>chgrp</tt> требуется только имя группы, имя пользователя не нужно.</p>

<h4>Синтаксис <tt>chgrp</tt></h4>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chgrp опции имя_группы /путь/к/директории
</pre></td></tr></table>

<p><blockquote>Вместо имени группы можно указать её <em>GID</em> (идентификатор группы)</blockquote></p>

<h4>Ключи и опции <tt>chgrp</tt></h4>

<ul>
	<li><tt>-c --changes</tt> - подробно описывать действия для каждого файла, чья группа изменяется;</li>
	<li><tt>-f --silent --quiet</tt> - не выдавать сообщения об ошибке для файлов, чья группа не может быть изменена;</li>
	<li><tt>-h --no-dereference</tt> - работать с символьными ссылками, а не файлами, на которые они указывают. Данная опция доступна, только если используется <tt>lchown</tt>;</li>
	<li><tt>-v --verbose</tt> - подробно описывать действие или отсутствие для <b>каждого</b> файла;</li>
	<li><tt>-R</tt> - рекурсивно изменить группы для каталогов и их содержимого, а возникающие ошибки не прекратят работу программы;</li>
	<li><tt>-L</tt> (<b>используется вместе с <tt>-R</tt></b>)- для каждого файла, указанного или пользователем, или встреченного при обходе дерева каталогов, если этот файл является симлинком на каталог, изменить группу самогО этого каталога и всех файлов в его иерархии;</li>
	<li><tt>-h</tt> - для каждого файла, являющегося символической ссылкой, изменить группу самой этой ссылки, а не объекта, на который она указывает, а если система не поддерживает группы для симлинков, то ничего не делать;</li>
	<li><tt>--</tt> - завершение списка опций.</li>
</ul>

<h4>Примеры использования <tt>chgrp</tt></h4>

<p>Опять же, перед изменением группы-владельца файла, проверьте с помощью <tt>ls</tt> текущую группу:</tt>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
ls -l 'ИМЯ_ФАЙЛА'
</pre></td></tr></table>

<p>Теперь добавьте некую группу <tt>mygroup</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo groupadd mygroup
</pre></td></tr></table>

<p>И сделайте группу <tt>mygroup</tt> владельцем директории <tt>/root/liveuser</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chgrp mygroup /root/liveuser
</pre></td></tr></table>

<p>Как и в случае с <tt>chown</tt>, группа стала владельцем только каталога <tt>/root/liveuser</tt>, но не файлов и подкаталогов этой директории. Чтобы изменить группу-владельца файла, можно, конечно, сделать вручную, а можно воспользоваться рекурсивным способом. За это отвечает ключ <tt>-R</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chgrp -R mygroup /root/liveuser/
</pre></td></tr></table>

<p>Однако, рекурсивный метод не назначает прав на симлинки, поэтому у них сохраняется прежняя группа. Чтобы установить новую группу и на символические ссылки, добавьте ключ <tt>-h</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chgrp -Rh mygroup /root/liveuser
</pre></td></tr></table>

<p>Для того, чтобы скопировать группу владельцев директории, воспользуйтесь ключом <tt>--reference</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo chgrp --reference /home/liveuser /root/liveuser
</pre></td></tr></table>

<h2>Специальные права доступа</h2>

<p>Для того, чтобы позволить <em>обычным</em> пользователям выполнять программы от имени суперпользователя, не зная его пароль, были созданы биты <tt>SUID</tt> и <tt>SGIG</tt>.</p>

<ol>
	<li>Если установлен бит <tt>SUID</tt>, то при выполнении программы, ID пользователя меняется на ID владельца файла. <em>Фактически</em>, это позволяет обычным пользователям запускать программы от имени суперюзера.</li>
	<li><tt>SGID</tt> работает аналогичным способом, но разница в том, что пользователь считается членом группы, с которой связан этот файл, а не групп, которым он действительно принадлежит. Если флаг <tt>SGID</tt> установлен на каталог, все файлы, созданные в нём, будут связаны с группой каталога, а не пользователя. Такое поведение используется для организации общих папок.</li>
	<li>Бит <tt>Sticky-bit</tt> так же используется для создания общих директорий. Когда он установлен, пользователь может только создавать, читать и выполнять файлы, но не может удалять их, если они принадлежат другим пользователям.</li>
</ol>

<h2>Условные обозначения</h2>

<p>Так же как и в предыдущих пунктах, опять просмотрите список файлов в подробном режиме:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
ls -l
</pre></td></tr></table>

<p>В первой колонке вывода <tt>ls</tt> выведены права на файл по следующей схеме:</p>

<p><em>Табл. 1 - буквенные обозначения прав на файлы</em></p>
<table border="1" width="100%" cellpadding="5">
	<tr>
		<td><b>Обозначение</b></td>
		<td><b>Расшифровка</b></td>
	</tr>
	<tr>
		<td><tt>---</tt></td>
		<td>Совсем нет прав</td>
	</tr>
	<tr>
		<td><tt>--x</tt></td>
		<td>Разрешено выполнение файла как программы, но не чтение и запись (в файл)</td>
	</tr>
	<tr>
		<td><tt>-w-</tt></td>
		<td>Разрешена запись в файл, но не чтение и не исполнение его как программы</td>
	</tr>
	<tr>
		<td><tt>-wx</tt></td>
		<td>Разрешена запись (изменение) в файл и его исполнение как программы, но не чтение</td>
	</tr>
	<tr>
		<td><tt>r--</tt></td>
		<td>Разрешено только чтение файла</td>
	</tr>
	<tr>
		<td><tt>r-x</tt></td>
		<td>Разрешено чтение и исполнение файла, но не запись в него (т.е., его изменение)</td>
	</tr>
	<tr>
		<td><tt>rw-</tt></td>
		<td>Разрешено чтение и запись в файл, но не его исполнение как программы</td>
	</tr>
	<tr>
		<td><tt>rwx</tt></td>
		<td>Разрешено всё: чтение, запись и исполнение</td>
	</tr>
</table>

<p><strong><img src="../../pic/note.png" /> Примечание</strong></p>

<p><blockquote><em>Запись</em> означает здесь <em>запись в файл</em>. Это поведение ещё можно охарактеризовать как <em>изменение файла</em></blockquote></p>

<p><em>Табл. 2 - буквенные обозначения прав</em></p>

<table border="1" width="100%" cellpadding="5">
	<tr>
		<td><b>Буква</b></td>
		<td><b>Обозначение</b></td>
	</tr>
	<tr>
		<td><tt>r</tt></td>
		<td>Чтение (<tt>Read</tt>)</td>
	</tr>
	<tr>
		<td><tt>w</tt></td>
		<td>Запись (<tt>Write</tt>)</td>
	</tr>
	<tr>
		<td><tt>x</tt></td>
		<td>Исполнение (<tt>eXecute</tt>)</td>
	</tr>
		<td><tt>s</tt></td>
		<td>Исполнение от имени <em>суперпользователя</em> (<tt>Superuser</tt>) - дополнительный</td>
	</tr>
</table>

<p><em>Табл. 3 - буквенные обозначения категорий пользователей</em></p>

<table border="1" width="100%" cellpadding="5">
	<tr>
		<td><b>Буква</b></td>
		<td><b>Обозначение</b></td>
	</tr>
	<tr>
		<td><tt>u</tt></td>
		<td>Владелец файла (<tt>User</tt>)</td>
	</tr>
	<tr>
		<td><tt>g</tt></td>
		<td>Группа файла (<tt>Group</tt>)</td>
	</tr>
	<tr>
		<td><tt>o</tt></td>
		<td>Все остальные (<tt>Other</tt>)</td>
	</tr>
</table>

<p>Действия так же можно записывать и с помощью цифр. Первая цифра указывает права для пользователя, вторая - для группы и третья для всех остальных.</p>

<p><em>Табл. 4 - цифровые обозначения прав доступа к файлам</em></p>

<table border="1" width="100%" cellpadding="5">
	<tr>
		<td><b>Цифра</b></td>
		<td><b>Обозначение</b></td>
	</tr>
	<tr>
		<td><tt>744</tt></td>
		<td>Разрешить всё для владельца, остальным только чтение</td>
	</tr>
	<tr>
		<td><tt>755</tt></td>
		<td>Разрешить всё для владельца, остальным только запуск (исполнение)</td>
	</tr>
	<tr>
		<td><tt>764</tt></td>
		<td>Разрешить всё для владельца, чтение и запись для группы, остальным только чтение</td>
	</tr>
	<tr>
		<td><tt>777</tt></td>
		<td>Всем разрешено всё</td>
	</tr>
</table>

<h3>Изменение прав доступа к файлам с помощью chmod</h3>

<p><tt>chmod</tt> - программа для изменения прав доступа к файлам.</p>

<h4>Синтаксис <tt>chmod</tt></h4>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chmod опции &lt;категория&gt;&lt;действие&gt;&lt;флаг&gt; файл
</pre></td></tr></table>

<h4>Ключи и опции <tt>chmod</tt></h4>

<ul>
	<li><tt>-c</tt> - выводить информацию обо всех изменениях;</li>
	<li><tt>-f</tt> - не выводить сообщения об ошибках;</li>
	<li><tt>-v</tt> - выводить максимум сообщений о ходе работы chmod;</li>
	<li><tt>-R</tt> - рекурсивный метод;</li>
	<li><tt>--reference</tt> - взять маску прав из указанного файла;</li>
	<li><tt>--preserve-root</tt> - не выполнять рекурсивные операции для корня файловой системы;</li>
</ul>

<h4>Примеры использования <tt>chmod</tt></h4>

<p>Разрешить выполнение определённого скрипта или бинарника пользователю (что лично мне надо чоень часто). Допустим, у нас есть некий ELF файл, который называется <tt>binary</tt>. И его надо сделать исполняемым. Для начала выполните <tt>ls -l binary</tt>, дабы просмотреть его текущие права.</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chmod u+x binary
</pre></td></tr></table>

<p>Теперь запускаем его:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
./binary
</pre></td></tr></table>

<p>Тоже самое, но с помощью цифр:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chmod 766 binary
</pre></td></tr></table>

<p>А теперь просмотрите, как изменились права на файл:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
ls -l binary
</pre></td></tr></table>

<p>Отберите все права у <tt>binary</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chmod ugo-rwx binary
</pre></td></tr></table>

<p>Файлы с правами 000 недоступны никаким пользователям, кроме суперпользователя и владельца. Вернём права обратно:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chmod 755 binary
</pre></td></tr></table>

<p>Для применения расширенных прав так же используется <tt>chmod</tt>. Нужно указать четырёхзначный аргумент в chmod, первая цифра относится к специальному разрешению, например:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
sudo mkdir binary.d
sudo chmod 2755 binary.d
</pre></td></tr></table>

<p>Эта команда добавит разрешение <tt>SGID</tt> на каталог <tt>binary.d</tt>.</p>

<p>Напомним цифровые обозначения <tt>SUID</tt>, <tt>SGID</tt> и <tt>Sticky bit</tt>:</p>

<p><em>Табл. 5 - цифровые обозначения <tt>SUID</tt>, <tt>SGID</tt> и <tt>Sticky bit</tt>.</em></p>

<table border="1" width="100%" cellpadding="5">
	<tr>
		<td><b>Число</b></td>
		<td><b>Обозначение</b></td>
	</tr>
	<tr>
		<td><tt>1</tt></td>
		<td>Sticky bit</td>
	</tr>
	<tr>
		<td><tt>2</tt></td>
		<td>SGID</td>
	</tr>
	<tr>
		<td><tt>4</tt></td>
		<td>SUID</td>
	</tr>
</table>

<p>Примеры использования <tt>chmod</tt>:</p>

<ul>
	<li>SUID:
<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chmod u+s
</pre></td></tr></table><br>
</li>
	<li>SGID:
<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chmod g+s
</pre></td></tr></table><br>
</li>
	<li>Sticky bit:
<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
chmod +t
</pre></td></tr></table><br>
</li>
</ul>

<h2>Дополнительная информация про SGID, SUID и Sticky bit</h2>

<h3>SUID</h3>

<p>Рассмотрим обычный для администратора пример. Нужно поменять пароль своей/чужой учётной записи. Для этого нужно отредактирвоать файл <tt>/etc/shadow</tt>. Но он доступен только суперпользователю. Однако, в утилите <tt>/bin/passwd</tt> применяется разрешение SUID. Это означает, что пользователь <b>временно</b> получит права <tt>root</tt>, что позволяет ему без проблем и ограничений редактировать <tt>/etc/shadow</tt>. Так ведь, если <tt>passwd</tt> именно это и делает? - редактирует нужный файл. Вот в этом и опасность разрешения SUID: с одной стороны, оно, однозначно, полезно и удобно, но довольно опасно. <b>Поэтому пользуйтесь им с осторожностью</b>.</p>

<h3>SGID</h3>

<p><tt>SGID</tt> - идентификатор группы. SGID даёт пользователю, который исполняет определённый файл, разрешения владельца группы этого файла, что означает, что SGID позволяет выполнить примерно тоже самое, что и SUID. Но, как ни странно, SGID для этой цели если используется, то очень редко, но как в случае с SUID, он применяется к некоторым системным файлам по умолчанию.</p>

<p>Однако, SGID может быть полезен тогда, когда он применяется к каталогу: вы можете использовать его для установки владельца группы по умолчанию для файлов и подкаталогов, созданных в этом каталоге. По умолчанию, когда пользователь создает файл, его эффективная первичная группа устанавливается как владелец группы для этого файла.</p>

<h3>Sticky bit</h3>

<p>Это разрешение полезно для защиты файлов от <em>случайного</em> удаления в среде, где несколько пользователей имеют права на запись в одну и ту же директорию; если применяется закреплённый sticky-bit, пользователь может удалить файл, только если он является пользователем-владельцем файла/каталога, в котором содержится файл. Именно поэтому он применяется, скажем, в <tt>/tmp</tt>.</p>

<p>Без sticky bit, если пользователь может создавать файлы в каталоге, он также может удалять файлы из этого каталога. В общедоступной групповой среде это может раздражать. Представьте себе пользователей user1 и user2, которые оба имеют права на запись в каталог <tt>/data/account</tt> и получают эти разрешения благодаря участию в группе <tt>account</tt>. Поэтому user1 может удалять файлы, созданные user2, и наоборот.</p>

<p>Когда вы применяете sticky bit, пользователь может удалять файлы, только если выполняется одно из следующих условий:</p>

<ol>
	<li>пользователь является владельцем файла;</li>
	<li>пользователь является владельцем директории с этим файлом.</li>
</ol>

<p>В первой колонке вывода <tt>ls -l</tt> у файлов с разрешением Sticky bit будет буква <tt>t</tt> в той позиции, где вы обычно видите разрешение на выполнение для других.</p>

<hr align="LEFT" width="100%" />

<table summary="Footer navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<td width="33%" align="left" valign="top"><a href="index.html"
accesskey="P">Назад</a></td>
<td width="34%" align="center" valign="top"><a href="index.html"
accesskey="H">Домой</a></td>
<td width="34%" align="right" valign="top"><a href="processes.html"
accesskey="N">Далее</a></td>

</tr>

<tr>
<td width="33%" align="left" valign="top">Администрирование системы</td>
<td width="34%" align="center" valign="top">&nbsp;</td>
<td width="33%" align="right" valign="top">Управление процессами</td>
</tr>
</table><br>
</body></html>
